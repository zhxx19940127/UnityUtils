# UnityUtils 项目技术文档

> 最后更新：2025-12-26 | 版本：基于项目当前状态

## 项目概述

**UnityUtils** 是一个面向 Unity 引擎开发者的高效实用工具集，采用模块化架构设计，包含大量常用静态工具方法、组件化设计、状态机、协程管理、事件系统等模块。项目旨在提升 Unity 开发效率、规范项目结构、简化常见功能实现。

### 核心特性
- **模块化架构**：各功能模块独立，支持按需集成
- **生产级质量**：完整的错误处理、线程安全、内存管理
- **性能优化**：对象池、缓存、延迟加载等优化技术
- **可扩展性**：插件式架构，易于添加新功能
- **完整文档**：每个模块都有详细的 README 文档
- **跨平台支持**：特别优化 WebGL 平台

## 项目结构总览

```
Assets/
├── Editor/                    # 编辑器工具
│   ├── AnchorTools.cs        # UI锚点工具（快速设置UI对齐）
│   ├── CreatOrRefreshPrefabs/ # 预制体创建/刷新工具
│   ├── EditorCoroutineRunner/ # 编辑器协程运行器
│   └── WebConfigGenerator.cs # Web配置生成器
├── GeneratedUITool/          # UI代码自动生成工具
│   ├── Editor/              # 编辑器界面
│   ├── UIMark.cs            # UI标记组件
│   └── README.md            # 详细文档（784行）
├── Resources/               # 资源文件
│   └── Weapons/             # 武器预制体（10个DataItem预制体）
├── Scenes/                  # 场景文件
│   └── Test.unity           # 测试场景
├── Scripts/                 # 核心脚本目录（所有功能模块）
│   ├── AssetBundleTools/    # AssetBundle工具系统（完整解决方案）
│   ├── Base/                # 基础架构（单例模板等）
│   ├── Context/             # 上下文管理系统
│   ├── CoroutineManager/    # 协程管理与策略工具
│   ├── DataSerialization/   # 数据序列化框架（策略模式）
│   ├── EventSystem/         # 事件系统 v2.1（高级特性）
│   ├── ReflectionToolkit/   # 反射缓存工具（性能优化）
│   ├── StatusManagementSystem/ # 状态管理系统
│   ├── StreamingAssetsLoader/ # 流式加载器
│   ├── TimerManager/        # 计时器管理
│   └── Utils/               # 常用工具类集合（30+工具类）
└── TextMesh Pro/            # TextMesh Pro资源
```

---

## 核心模块详细分析

### 1. DataSerialization 模块

**设计理念**：基于策略模式的可扩展序列化框架，专注"数据格式转换"，彻底分离文件I/O职责。

#### 架构设计
- **策略模式**：每种序列化格式作为独立策略实现
- **单一职责**：仅负责序列化/反序列化，不包含文件读写
- **插件式扩展**：运行时动态注册新策略
- **统一入口**：通过 `SerializationManager` 提供一致性API

#### 核心接口
```csharp
// 策略接口定义
public interface ISerializationStrategy
{
    string[] SupportedExtensions { get; }
    string FormatName { get; }
    bool SupportsCompression { get; }

    string Serialize(object obj);
    byte[] SerializeToBytes(object obj);
    T Deserialize<T>(string data) where T : new();
    T DeserializeFromBytes<T>(byte[] data) where T : new();
}
```

#### 内置策略
1. **JsonSerializationStrategy**：基于 LitJson 库实现
2. **XmlSerializationStrategy**：标准 XML 序列化
3. **BinarySerializationStrategy**：二进制格式序列化
4. **CsvSerializationStrategy**：CSV 格式序列化
5. **SoapXmlSerializationStrategy**：SOAP XML 格式（新增未跟踪文件）

#### SoapXmlSerializationStrategy 分析
- **功能**：支持 SOAP 信封格式包装和提取
- **特性**：
  - 完整的 SOAP 数据模型定义（SoapEnvelope、SoapBody、DataListResponse 等）
  - 支持 SOAP 1.1 和 SOAP 1.2 命名空间
  - 线程安全的 XML 解析
  - 优雅的错误处理和日志记录
- **用途**：适合与 Web 服务（SOAP API）集成

#### 使用示例
```csharp
// 序列化管理器使用
var manager = SerializationManager.Instance;
manager.RegisterStrategy<JsonSerializationStrategy>();

string json = manager.Serialize<JsonSerializationStrategy>(data);
byte[] bytes = manager.SerializeToBytes<BinarySerializationStrategy>(data);

// 直接使用策略
var xmlStrategy = new XmlSerializationStrategy();
string xml = xmlStrategy.Serialize(obj);
```

### 2. EventSystem v2.1 模块

**设计理念**：高度模块化的事件系统，支持拦截器、异步处理、压力测试，v2.1 新增精细化日志控制。

#### 架构组件
```
Message（门面类）
├── IEventBus（事件总线）
├── IEventRegistry（事件注册管理器）
├── IEventDispatcher（事件分发器）
├── IMemoryManager（内存管理器）
├── IAsyncProcessor（异步处理器）
└── IInterceptorManager（拦截器管理器）
```

#### v2.1 新增特性
1. **四级日志控制**：
   - `SubscriberLogLevel.All`：记录所有日志
   - `SubscriberLogLevel.RegistrationOnly`：仅记录注册相关
   - `SubscriberLogLevel.DispatchOnly`：仅记录分发相关
   - `SubscriberLogLevel.None`：不记录日志

2. **声明式日志配置**：
   ```csharp
   [Subscriber(logLevel: SubscriberLogLevel.DispatchOnly)]
   private void OnEvent(MyEvent e) { ... }
   ```

3. **线程安全日志**：自动检测主线程/后台线程

#### 拦截器系统
```csharp
// 5种专业拦截器
public enum InterceptorType
{
    ParameterValidation,  // 参数验证拦截器
    PermissionControl,    // 权限控制拦截器
    RateLimiting,        // 速率限制拦截器
    PerformanceMonitor,  // 性能监控拦截器
    CustomInterceptor    // 自定义拦截器
}
```

#### 压力测试框架
- **并发测试**：模拟高并发事件处理
- **内存测试**：检测内存泄漏
- **吞吐量测试**：评估系统处理能力

#### 使用示例
```csharp
// 订阅事件
[Subscriber]
private void OnPlayerDamage(DamageEvent e)
{
    // 处理伤害事件
}

// 发布事件
Message.Publish(new DamageEvent { Damage = 100, Target = enemy });

// 注册拦截器
Message.InterceptorManager.Register(
    InterceptorType.ParameterValidation,
    new DamageValidationInterceptor()
);
```

### 3. AssetBundleTools 模块

**设计理念**：完整的 AssetBundle 打包、加载和管理解决方案，提供可视化编辑器工具和高效运行时管理器。

#### 编辑器工具（AssetBundleBuilderWindow）
- **可视化界面**：1498行代码的完整编辑器窗口
- **核心功能**：
  - 拖拽配置打包路径
  - 模型选择打包（部分模型打包）
  - Shader 自动管理（防止粉红色材质）
  - WebGL 平台优化配置

#### 运行时管理器
- **AssetBundleManager**：单例模式，负责加载、缓存和卸载
- **AssetBundleConfig**：配置管理和路径处理

#### 智能特性
1. **依赖分析**：自动分析资源依赖关系
2. **引用计数**：智能缓存管理
3. **并发控制**：WebGL 平台请求队列控制
4. **配置持久化**：所有设置保存到 EditorPrefs

#### 使用流程
```csharp
// 运行时加载
await AssetBundleManager.Instance.LoadAsync("weapons");
GameObject sword = AssetBundleManager.Instance.LoadAsset<GameObject>("Sword");

// 编辑器打包
// 1. 打开 AssetBundleBuilderWindow
// 2. 配置路径和选项
// 3. 点击 Build 按钮
```

### 4. CoroutineManager 模块

**设计理念**：高级协程管理器，使用策略模式统一管理所有协程，支持池化、命名、分类和自动清理。

#### 策略模式实现
```csharp
// 策略接口
public interface ICoroutineStrategy
{
    IEnumerator Execute(CoroutineArgs args);
    void Cleanup();
}

// 内置策略
public class DelayedActionStrategy : ICoroutineStrategy { }    // 延迟执行
public class LerpValueStrategy : ICoroutineStrategy { }        // 插值动画
public class ShakeStrategy : ICoroutineStrategy { }            // 抖动效果
public class WaitConditionStrategy : ICoroutineStrategy { }    // 条件等待
```

#### 协程池系统
- **最大容量**：200个池化协程
- **自动清理**：空闲协程自动回收
- **命名管理**：支持按名称停止协程
- **分类管理**：可按分类批量管理

#### 性能统计
```csharp
public class CoroutineStats
{
    public int TotalStarted { get; }      // 总启动数
    public int ActiveCount { get; }       // 活动协程数
    public int PooledCount { get; }       // 池化协程数
    public float AvgDuration { get; }     // 平均持续时间
}
```

#### 使用示例
```csharp
// 使用协程管理器
CoroutineManager.Start(
    strategy: new LerpValueStrategy(),
    args: new LerpValueArgs
    {
        From = 0f,
        To = 1f,
        Duration = 2f,
        OnUpdate = value => image.fillAmount = value
    },
    name: "FadeInEffect"
);

// 停止协程
CoroutineManager.Stop("FadeInEffect");
CoroutineManager.StopAllInCategory("UIAnimations");
```

### 5. ReflectionToolkit 模块

**设计理念**：反射缓存工具，对高频反射操作提供预加载、缓存、清理功能，显著提升反射性能。

#### 架构设计
```
ReflectionToolkit（统一入口）
├── ReflectionCacheManager（缓存管理器）
├── ICacheModule（缓存模块接口）
│   ├── TypeCacheModule（类型缓存）
│   ├── MethodCacheModule（方法缓存）
│   ├── PropertyCacheModule（属性缓存）
│   └── DelegateCacheModule（委托缓存）
└── ICleanupStrategy（清理策略接口）
    ├── LRUCleanupStrategy（最近最少使用）
    ├── UsageBasedCleanupStrategy（使用频率）
    ├── MemoryPressureCleanupStrategy（内存压力）
    └── AdaptiveCleanupStrategy（自适应）
```

#### 缓存统计
```csharp
public class CacheStatistics
{
    public int TotalCachedItems { get; }      // 缓存总项数
    public float HitRate { get; }             // 命中率
    public long MemoryUsage { get; }          // 内存使用量
    public Dictionary<string, int> UsageFrequency { get; } // 使用频率
}
```

#### 使用示例
```csharp
// 获取类型信息（带缓存）
Type type = ReflectionToolkit.GetType("MyNamespace.MyClass");

// 获取方法信息
MethodInfo method = ReflectionToolkit.GetMethod(
    typeof(MyClass),
    "MyMethod",
    BindingFlags.Public | BindingFlags.Instance
);

// 清理缓存
ReflectionToolkit.Cleanup(CleanupMode.UsageBased);
```

### 6. StatusManagementSystem 模块

**设计理念**：灵活的状态机架构，支持延迟加载、状态切换验证、历史记录、事件监听，适合角色AI、UI状态管理等场景。

#### 核心类设计
```csharp
// 泛型状态管理器
public class Modes<ParentT> where ParentT : class
{
    // 状态管理
    public IMode<ParentT> CurrentMode { get; }
    public IReadOnlyDictionary<string, IMode<ParentT>> AvailableModes { get; }

    // 历史记录
    public Stack<IMode<ParentT>> History { get; }

    // 事件
    public event Action<IMode<ParentT>, IMode<ParentT>> OnModeChanged;
}

// 状态接口
public interface IMode<ParentT> where ParentT : class
{
    string Name { get; }
    void Enter(ParentT parent);
    void Update(ParentT parent);
    void Exit(ParentT parent);
}
```

#### 特性
1. **延迟加载**：状态实例按需创建
2. **状态池**：复用状态实例，减少GC
3. **历史记录**：支持状态回退（Undo/Redo）
4. **异步切换**：支持异步状态转换
5. **验证系统**：状态切换前验证条件

#### 使用示例
```csharp
// 定义状态
public class IdleMode : ModeBase<Player>
{
    public override void Enter(Player player)
    {
        player.Animator.Play("Idle");
    }

    public override void Update(Player player)
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            player.Modes.SwitchTo("Jump");
        }
    }
}

// 状态管理器使用
player.Modes.Register<IdleMode>("Idle");
player.Modes.Register<JumpMode>("Jump");
player.Modes.SwitchTo("Idle");
```

### 7. Context 模块

**设计理念**：用于管理应用程序中的全局对象和资源，支持类型键和字符串键双重存储。

#### 架构特点
- **部分类设计**：将大功能拆分为多个文件
- **双重键存储**：支持 `Type` 键和 `string` 键
- **命名上下文**：支持多个独立的上下文实例
- **资源自动释放**：自动释放所有 `IDisposable` 对象

#### 核心方法
```csharp
public partial class Context
{
    // 存储和获取
    public void Set<T>(T value) where T : class;
    public T Get<T>() where T : class;
    public bool TryGet<T>(out T value) where T : class;

    // 命名上下文
    public static Context GetNamed(string name);
    public static void ReleaseNamed(string name);

    // 资源管理
    public void RegisterDisposable(IDisposable disposable);
    public void Cleanup();
}
```

#### 使用示例
```csharp
// 设置全局服务
Context.Set<IAudioService>(new AudioService());
Context.Set<INetworkService>(new NetworkService());

// 获取服务
var audioService = Context.Get<IAudioService>();
if (Context.TryGet<INetworkService>(out var networkService))
{
    // 使用服务
}

// 命名上下文（隔离的上下文）
var playerContext = Context.GetNamed("Player1");
playerContext.Set<PlayerInventory>(new Inventory());
```

### 8. Utils 工具类集合

包含30+实用工具类，涵盖动画、物理、UI、文件、调试等各个方面。

#### 主要工具类

| 类别 | 工具类 | 功能描述 |
|------|--------|----------|
| **动画** | `TweenUtils` | 属性补间动画，支持缓动函数 |
| **物理** | `CollisionUtils` | 碰撞检测算法集合 |
| **路径** | `PathfindingUtils` | A*算法、NavMesh路径查找 |
| **图像** | `ImageUtils` | 图片加载、保存、格式转换 |
| **音频** | `AudioUtils` | 音频播放、混合、效果处理 |
| **视频** | `VideoUtils` | 视频播放控制 |
| **剪贴板** | `ClipboardUtils` | 跨平台剪贴板操作 |
| **设备** | `DeviceUtils` | 设备硬件信息获取 |
| **正则** | `RegexUtils` | 正则表达式工具 |
| **文件** | `FileUtils` | 文件读写、目录操作 |
| **UI** | `UIUtils` | UI组件操作、布局工具 |
| **调试** | `DebugLogger` | 统一调试日志，支持详细日志级别 |
| **数学** | `MathUtils` | 数学运算工具 |
| **随机** | `RandomUtils` | 随机数生成器 |
| **对象** | `GameObjectUtils` | 游戏对象管理工具 |

#### 使用示例
```csharp
// Tween动画
TweenUtils.TweenFloat(
    startValue: 0f,
    endValue: 1f,
    duration: 2f,
    onUpdate: value => image.alpha = value,
    easing: EaseType.InOutQuad
);

// 碰撞检测
if (CollisionUtils.SphereCast(
    origin: player.position,
    radius: 1f,
    direction: player.forward,
    maxDistance: 10f,
    out var hitInfo))
{
    // 处理碰撞
}

// 文件操作
string content = FileUtils.ReadAllText("config.json");
FileUtils.WriteAllText("log.txt", $"Time: {DateTime.Now}");
```

## 设计模式总结

### 策略模式（Strategy Pattern）
- **DataSerialization**：不同序列化格式作为策略
- **CoroutineManager**：协程执行策略
- **ReflectionToolkit**：缓存清理策略

### 单例模式（Singleton Pattern）
- **AssetBundleManager**：资源管理单例
- **MonoSingleton<T>**：MonoBehaviour单例基类
- **SerializationManager**：序列化管理单例

### 工厂模式（Factory Pattern）
- 策略的延迟初始化和创建
- 状态实例的按需创建

### 门面模式（Facade Pattern）
- **Message**：事件系统统一门面
- **SerializationManager**：序列化统一入口

### 观察者模式（Observer Pattern）
- **EventSystem**：事件发布订阅机制
- **StatusManagementSystem**：状态变更通知

### 对象池模式（Object Pool Pattern）
- **EventSystem**：消息对象池
- **CoroutineManager**：协程对象池
- **StatusManagementSystem**：状态对象池

### 责任链模式（Chain of Responsibility）
- **EventSystem**：拦截器链式处理

### 建造者模式（Builder Pattern）
- **StatusManagementSystem**：状态配置器

### 依赖注入（Dependency Injection）
- 通过 **Context** 模块实现服务定位

## 架构特点

### 1. 模块化设计
- 各功能模块物理分离，低耦合
- 独立编译和测试能力
- 可按需集成到项目中

### 2. 插件式架构
- 运行时动态注册新策略
- 可扩展的接口设计
- 支持第三方插件集成

### 3. 性能优化
- **对象池**：减少GC压力
- **缓存系统**：提升高频操作性能
- **延迟加载**：按需初始化资源
- **异步处理**：无阻塞操作

### 4. 错误处理
- 完整的异常捕获和日志记录
- 优雅的降级处理
- 详细的错误信息

### 5. 线程安全
- 主线程/后台线程自动切换
- 线程安全的集合操作
- 异步操作的完整性保证

### 6. 配置驱动
- 编辑器可视化配置
- 运行时动态配置
- 配置持久化支持

## 使用指南

### 集成到现有项目
1. **选择性集成**：仅复制需要的模块目录
2. **依赖检查**：确保项目有必要的依赖（如 LitJson）
3. **命名空间**：所有代码在 `UnityUtils` 命名空间下
4. **版本兼容**：确保 Unity 版本兼容性（2022.3+）

### 最佳实践
1. **事件系统**：使用强类型事件，避免字符串事件
2. **序列化**：优先使用 Json 格式，便于调试
3. **协程管理**：使用命名协程，便于调试和管理
4. **状态管理**：合理设计状态粒度，避免状态爆炸
5. **资源管理**：及时释放不需要的资源

### 调试技巧
1. **事件日志**：使用 `SubscriberLogLevel` 控制日志级别
2. **性能分析**：使用 ReflectionToolkit 的统计功能
3. **内存监控**：使用 EventSystem 的内存管理工具
4. **协程调试**：使用 CoroutineManager 的统计信息

## 未跟踪文件状态

根据当前 git 状态，有以下未跟踪文件：

### 1. Resources/Weapons/ 目录
- **内容**：10个 DataItem 预制体（DataItem_1.prefab 到 DataItem_10.prefab）
- **用途**：示例资源或测试资源
- **建议**：可作为示例资源保留，或根据实际需要处理

### 2. Scripts/DataSerialization/Strategy/SoapXmlSerializationStrategy.cs
- **状态**：已实现但未跟踪的 SOAP XML 序列化策略
- **功能**：完整的 SOAP 信封格式支持
- **建议**：应添加到版本控制，作为 DataSerialization 模块的扩展

## 项目技术栈

- **Unity 版本**：2022.3+（基于 API 使用推断）
- **C# 版本**：8.0+（使用 nullable reference types、async/await 等特性）
- **依赖库**：
  - LitJson：JSON 序列化
  - System.Xml：XML 处理
  - System.IO.Compression：压缩支持
- **.NET 兼容性**：.NET Standard 2.0

## 适用场景

### 推荐使用场景
1. **大型游戏项目**：复杂的事件交互和状态管理需求
2. **企业级应用**：需要严格的安全和稳定性保障
3. **性能敏感应用**：高频事件处理和内存优化要求
4. **团队协作项目**：清晰的架构和文档支持
5. **跨平台项目**：特别是 WebGL 平台优化需求

### 不适用场景
1. **超小型项目**：简单项目可能过度工程化
2. **快速原型**：需要快速迭代的早期阶段
3. **特定领域项目**：已有成熟框架的领域（如 VR/AR 专用框架）

## 扩展建议

基于项目现有架构和模块化设计，以下是不同时间维度的扩展建议：

### 一、短期扩展（1-2周可完成）

#### 1. Protobuf 序列化策略
**当前基础**：DataSerialization 模块已采用策略模式，支持 JSON、XML、Binary、CSV 和 SOAP XML 格式。`ISerializationStrategy` 接口定义清晰，`SerializationManager` 支持插件式注册。

**实现思路**：
- 引入 `protobuf-net` 库（更适合 Unity 工作流）或 `Google.Protobuf`（官方标准）
- 创建 `ProtobufSerializationStrategy` 类实现 `ISerializationStrategy` 接口
- 扩展 `SerializationFormat` 枚举添加 `Protobuf` 选项
- 通过 `SerializationManager.RegisterStrategy()` 注册新策略
- 提供 `.proto` 文件编译工具或使用 `[ProtoContract]` 属性标记

**技术细节**：
```csharp
// 扩展枚举
public enum SerializationFormat { Binary, Json, Xml, Csv, Protobuf }

// 策略实现核心
public class ProtobufSerializationStrategy : ISerializationStrategy
{
    public string[] SupportedExtensions => new[] { ".protobuf", ".pb", ".bin" };
    public string FormatName => "Protobuf";
    public bool SupportsCompression => true;

    public byte[] SerializeToBytes(object obj)
    {
        using (var stream = new MemoryStream())
        {
            ProtoBuf.Serializer.Serialize(stream, obj);
            return stream.ToArray();
        }
    }
    // ... 其他接口实现
}
```

**价值**：
- 更高性能的二进制序列化，数据体积减少 30-50%
- 适合网络传输和持久化存储
- 向前/向后兼容性支持（字段版本管理）

**技术难度**：★★☆☆☆（架构兼容性好，仅需集成现有库）

---

#### 2. 网络模块封装
**当前基础**：EventSystem v2.1 具备完整的事件机制和拦截器系统，支持异步处理和压力测试。

**实现思路**：
- 创建 `NetworkManager` 单例类，统一管理 HTTP/WebSocket 通信
- 将网络请求/响应封装为事件（如 `NetworkRequestEvent`、`NetworkResponseEvent`）
- 利用 EventSystem 拦截器实现网络日志、自动重试、请求缓存、速率限制
- 支持 RESTful API 和 WebSocket 实时通信
- 与 Context 模块集成，提供全局网络服务访问

**核心功能**：
- 统一 API：`NetworkManager.SendRequest<T>(url, data)`、`NetworkManager.ConnectWebSocket(url)`
- 事件驱动：网络响应自动转换为事件，业务层通过 `[Subscriber]` 订阅
- 拦截器链：认证拦截器、日志拦截器、缓存拦截器、错误处理拦截器
- 性能监控：请求耗时统计、成功率监控、自动降级

**价值**：
- 统一网络层，简化网络通信代码
- 事件驱动架构，解耦网络逻辑和业务逻辑
- 可扩展的拦截器系统，便于添加新功能（如加密、压缩）
- 内置性能监控和调试工具

**技术难度**：★★★☆☆（需设计良好的事件模型和错误处理）

---

#### 3. 本地化系统
**当前基础**：Context 模块可管理全局资源，Utils 包含 `FileUtils` 文件操作工具，`DataSerialization` 支持多种文本格式。

**实现思路**：
- 创建 `LocalizationManager` 单例管理多语言文本
- 支持 CSV/JSON 格式的语言文件（复用现有序列化策略）
- 提供编辑器工具导入/导出翻译文件
- 与 `UIUtils` 集成，支持 UI 文本自动本地化
- 动态语言切换和实时更新

**架构设计**：
```
LocalizationManager
├── 语言资源管理（加载、缓存、更新）
├── 文本键值映射系统
├── 动态参数替换（如 "Hello {name}"）
├── 复数形式处理（单数/复数）
├── 编辑器工具（翻译表编辑、导入/导出）
└── UI 集成组件（自动绑定 Text/TMP 组件）
```

**价值**：
- 完整的国际化支持，便于多语言项目
- 与现有工具链无缝集成
- 运行时动态切换语言
- 减少重复的本地化代码

**技术难度**：★★☆☆☆（主要为业务逻辑，技术复杂度低）

---

### 二、中期扩展（1-2月可完成）

#### 4. ECS 集成支持
**当前基础**：StatusManagementSystem 有状态机架构，CoroutineManager 有协程管理，EventSystem 支持事件驱动。

**实现思路**：
- 创建基础 ECS 框架：`Entity`、`Component`、`System` 核心类
- 与现有 EventSystem 深度集成，实现 ECS 事件驱动
- 提供 Entity 查询系统（基于组件类型的高效查询）
- 性能监控和调试工具集成
- 创建示例：基于 ECS 的角色移动、动画、碰撞系统

**技术架构**：
```csharp
// 基于现有模式的 ECS 扩展
public class EcsManager : MonoSingleton<EcsManager>
{
    private List<IEcsSystem> _systems = new List<IEcsSystem>();

    // 与 EventSystem 集成
    [Subscriber]
    private void OnEntityCreated(EntityCreatedEvent e) { /* 处理实体创建 */ }
}

// 组件定义
public struct TransformComponent : IEcsComponent
{
    public Vector3 Position;
    public Quaternion Rotation;
    public Vector3 Scale;
}

// 系统定义
public class MovementSystem : IEcsSystem
{
    public void Update(float deltaTime)
    {
        // 处理所有具有 TransformComponent 和 VelocityComponent 的实体
    }
}
```

**价值**：
- 支持数据导向设计，提升大规模实体性能（1000+ 实体）
- 与现有事件系统深度集成，架构一致
- 适合性能敏感的游戏场景（如 RTS、模拟类游戏）

**技术难度**：★★★★☆（需要深入理解 ECS 架构和性能优化）

---

#### 5. AI 行为树系统
**当前基础**：StatusManagementSystem 已具备状态机基础，CoroutineManager 支持协程策略。

**实现思路**：
- 基于 `IMode<ParentT>` 接口扩展行为树节点系统
- 实现标准行为树节点：选择、序列、并行、条件、动作、装饰器
- 提供可视化编辑器（可复用 AssetBundleTools 的编辑器框架）
- 与现有状态系统无缝集成，支持行为树和状态机混合使用
- 性能优化：节点缓存、条件预计算、并行执行

**节点类型**：
- **Composite Nodes**：Selector（选择）、Sequence（序列）、Parallel（并行）
- **Decorator Nodes**：Inverter（取反）、Repeater（重复）、Timeout（超时）
- **Leaf Nodes**：Action（动作）、Condition（条件）、Wait（等待）

**可视化编辑器特性**：
- 拖拽式节点编辑
- 实时行为树调试和状态可视化
- 性能分析（节点执行时间统计）
- 导出为 JSON/二进制格式

**价值**：
- 更灵活的 AI 行为控制，适合复杂游戏 AI
- 可视化编辑降低使用门槛
- 与现有状态管理系统互补
- 性能可控，支持大规模 AI 实体

**技术难度**：★★★★☆（编辑器部分复杂度较高）

---

#### 6. 存档系统解决方案
**当前基础**：DataSerialization 支持多种格式，Context 管理全局对象，Utils 提供文件操作。

**实现思路**：
- 创建 `SaveSystem` 统一管理游戏存档
- 支持增量保存、自动保存、多存档槽位
- 集成加密和压缩（复用序列化策略的压缩功能）
- 版本兼容和迁移工具
- 存档验证和完整性检查

**核心功能**：
- **存档管理**：创建、加载、删除、重命名存档
- **增量保存**：仅保存变化的数据，提升保存速度
- **自动保存**：定时或触发式自动保存，支持防损毁设计
- **版本兼容**：自动处理不同版本存档的迁移
- **云存档**：扩展支持云存储（需网络模块支持）

**架构设计**：
```
SaveSystem
├── 存档管理器（SaveManager）
├── 数据序列化层（复用 DataSerialization）
├── 文件操作层（复用 FileUtils）
├── 加密压缩层（可选）
├── 版本迁移器（VersionMigrator）
└── 云存档适配器（扩展）
```

**价值**：
- 完整的游戏存档解决方案，减少重复开发
- 支持复杂的存档需求（多存档、云存档、版本迁移）
- 与现有工具链无缝集成
- 生产级错误处理和恢复机制

**技术难度**：★★★☆☆（主要复杂度在版本管理和错误恢复）

---

### 三、长期愿景（战略发展方向）

#### 7. 可视化编辑器集成
**当前基础**：AssetBundleTools 有完整编辑器窗口（1498行代码），GeneratedUITool 有 UI 生成经验。

**实现思路**：
- 为每个核心模块创建统一的编辑器配置窗口
- 拖拽式配置界面（事件订阅配置、状态机配置、行为树编辑）
- 实时预览和调试工具
- 导出配置文件供运行时使用
- 插件式架构支持第三方模块编辑器扩展

**编辑器矩阵**：
| 模块 | 编辑器功能 |
|------|------------|
| EventSystem | 事件订阅关系图、拦截器配置、性能监控 |
| StatusManagementSystem | 状态机可视化编辑、状态转换调试 |
| DataSerialization | 序列化格式比较、性能测试工具 |
| CoroutineManager | 协程执行可视化、性能分析 |
| ECS（如实现） | 实体组件查看器、系统执行时序图 |

**价值**：
- 大幅降低使用门槛，提升开发效率
- 可视化调试，便于问题排查
- 配置驱动，减少硬编码
- 统一的用户体验，提升工具专业性

**技术难度**：★★★★★（需要完整的编辑器框架和UI系统）

---

#### 8. 代码生成器扩展
**当前基础**：GeneratedUITool 已有 UI 代码生成基础，ReflectionToolkit 有反射能力。

**实现思路**：
- 基于 Roslyn 或模板引擎扩展代码生成能力
- 支持多种代码生成场景：事件订阅代码、序列化类、ECS 组件、API 客户端
- 与 Unity 编辑器深度集成，右键菜单快速生成
- 模板系统支持自定义生成规则
- 代码质量检查（命名规范、依赖分析）

**生成场景**：
- **事件代码生成**：根据事件定义自动生成订阅/发布代码
- **序列化类生成**：从 JSON/XML 示例生成 C# 类
- **API 客户端生成**：从 OpenAPI/Swagger 定义生成网络客户端
- **ECS 组件生成**：根据数据结构自动生成组件代码

**价值**：
- 减少样板代码，提升开发效率
- 提升代码一致性和规范性
- 降低手动编写错误
- 支持团队协作和代码规范

**技术难度**：★★★★★（需要深入的编译器和模板引擎知识）

---

#### 9. 性能分析套件
**当前基础**：EventSystem 有压力测试框架，ReflectionToolkit 有统计功能，CoroutineManager 有性能监控。

**实现思路**：
- 创建统一的性能监控框架 `PerformanceMonitor`
- 实时显示内存、CPU、GPU、帧率等关键指标
- 模块级性能分析：事件吞吐量、协程性能、序列化速度
- 性能报告生成和趋势分析
- 自动性能建议和优化提示

**监控维度**：
- **运行时性能**：帧率、内存、GC 频率、对象分配
- **模块性能**：事件处理延迟、协程执行时间、序列化速度
- **资源使用**：纹理内存、网格数量、材质实例
- **网络性能**：请求延迟、带宽使用、错误率

**价值**：
- 系统性性能优化工具，提升项目质量
- 问题早期发现和定位
- 性能基准测试和回归检测
- 数据驱动的优化决策

**技术难度**：★★★★★（需要全面的性能监控和分析能力）

---

### 四、技术可行性分析

| 扩展项 | 技术难度 | 现有基础 | 用户价值 | 推荐指数 | 依赖程度 |
|--------|----------|----------|----------|----------|----------|
| **短期扩展** | | | | | |
| Protobuf 序列化 | ★★☆☆☆ | ★★★★★ | ★★★★☆ | ★★★★★ | 低（仅需集成库） |
| 网络模块 | ★★★☆☆ | ★★★★☆ | ★★★★★ | ★★★★★ | 中（需设计事件模型） |
| 本地化系统 | ★★☆☆☆ | ★★★☆☆ | ★★★☆☆ | ★★★☆☆ | 低（主要为业务逻辑） |
| **中期扩展** | | | | | |
| ECS 集成 | ★★★★★ | ★★☆☆☆ | ★★★★☆ | ★★★☆☆ | 高（需全新架构） |
| AI 行为树 | ★★★★☆ | ★★★☆☆ | ★★★★☆ | ★★★★☆ | 中（有状态机基础） |
| 存档系统 | ★★★☆☆ | ★★★★★ | ★★★★★ | ★★★★★ | 低（复用现有模块） |
| **长期愿景** | | | | | |
| 可视化编辑器 | ★★★★★ | ★★★☆☆ | ★★★★☆ | ★★★☆☆ | 高（需完整UI框架） |
| 代码生成器 | ★★★★★ | ★★★☆☆ | ★★★★☆ | ★★★☆☆ | 高（需编译器知识） |
| 性能分析套件 | ★★★★★ | ★★★☆☆ | ★★★★☆ | ★★★☆☆ | 高（需全面监控） |

---

### 五、实施优先级建议

#### 最高优先级（技术债务和基础建设）
1. **Protobuf 序列化** - 基础能力扩展，需求明确，集成简单
2. **网络模块** - 现代应用必备，复用现有事件系统，架构收益高
3. **存档系统** - 游戏项目刚需，现有技术基础好，复用程度高

#### 中等优先级（专业领域扩展）
4. **AI 行为树** - 游戏项目专用，有差异化价值，有状态机基础
5. **本地化系统** - 国际化需求，技术复杂度低，可作为示例项目

#### 远期规划（生态建设）
6. **可视化编辑器** - 提升易用性，扩大用户群，但开发成本高
7. **ECS 集成** - 面向性能敏感项目，技术门槛高，需验证需求
8. **代码生成器** - 提升开发效率，但需要深入的编译器知识
9. **性能分析套件** - 专业级工具，适合大型项目，投入产出比需评估

#### 实施策略建议
1. **迭代开发**：从短期扩展到中期再到长期，逐步验证需求
2. **模块独立**：每个扩展作为独立模块，可单独集成和使用
3. **用户反馈驱动**：优先实现用户需求最强烈的功能
4. **文档和示例**：每完成一个扩展，提供完整文档和使用示例
5. **社区协作**：复杂功能（如可视化编辑器）可考虑社区贡献

---

## 贡献指南

### 代码规范
1. **命名规范**：PascalCase 类名，camelCase 变量名
2. **注释要求**：公共API必须有XML文档注释
3. **错误处理**：使用 try-catch 包装可能失败的操作
4. **日志记录**：使用 `Debug.Log` 系列方法，带模块前缀

### 测试要求
1. **单元测试**：核心功能应有单元测试
2. **集成测试**：模块间集成测试
3. **性能测试**：性能敏感模块应有性能测试

### 文档要求
1. **README**：每个模块必须有 README.md
2. **API文档**：公共API必须有XML文档注释
3. **示例代码**：提供使用示例

---

## 许可证信息

项目采用 MIT 许可证，允许自由使用、修改和分发。

**免责声明**：本工具集按"原样"提供，作者不对使用本工具集造成的任何损失负责。在生产环境中使用前请充分测试。

---

*文档生成时间：2025-12-26*
*基于项目版本：main 分支最新提交*
*文档维护者：Claude Code*